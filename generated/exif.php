<?php

namespace Safe;

use Safe\Exceptions\ExifException;

/**
 * exif_imagetype reads the first bytes of an image and
 * checks its signature.
 *
 * exif_imagetype can be used to avoid calls to other
 * exif functions with unsupported file types
 * or in conjunction with $_SERVER['HTTP_ACCEPT'] to check
 * whether or not the viewer is able to see a specific image in the browser.
 *
 * @param string $filename
 * @return int When a correct signature is found, the appropriate constant value will be
 * returned otherwise the return value is FALSE. The return value is the
 * same value that getimagesize returns in index 2 but
 * exif_imagetype is much faster.
 * @throws ExifException
 *
 */
function exif_imagetype(string $filename): int
{
    error_clear_last();
    $result = \exif_imagetype($filename);
    if ($result === false) {
        throw ExifException::createFromPhpError();
    }
    return $result;
}


/**
 * exif_read_data reads the
 * EXIF headers from an image file. This way you can read meta data
 * generated by digital cameras.
 *
 * EXIF headers tend to be present in JPEG/TIFF images generated by digital
 * cameras, but unfortunately each digital camera maker has a different
 * idea of how to actually tag their images, so you can't always rely on
 * a specific Exif header being present.
 *
 * Height and Width are computed the
 * same way getimagesize does so their values must not be
 * part of any header returned.  Also, html is a
 * height/width text string to be used inside normal HTML.
 *
 * When an Exif header contains a Copyright note, this itself can contain two
 * values. As the solution is inconsistent in the Exif 2.10 standard, the
 * COMPUTED section will return both entries
 * Copyright.Photographer and
 * Copyright.Editor while the IFD0
 * sections contains the byte array with the NULL character that splits both
 * entries. Or just the first entry if the datatype was wrong (normal behaviour
 * of Exif). The COMPUTED will also contain the entry
 * Copyright which is either the original copyright string,
 * or a comma separated list of the photo and editor copyright.
 *
 * The tag UserComment has the same problem as the Copyright
 * tag. It can store two values.  First the encoding used, and second the value
 * itself. If so the IFD section only contains the encoding
 * or a byte array. The COMPUTED section will store both in
 * the entries UserCommentEncoding and
 * UserComment. The entry UserComment
 * is available in both cases so it should be used in preference to the value
 * in IFD0 section.
 *
 * exif_read_data also validates EXIF data tags according
 * to the EXIF specification (http://exif.org/Exif2-2.PDF, page 20).
 *
 * @param string|resource $file The location of the image file. This can either be a path to the file
 * (stream wrappers are also supported as usual)
 * or a stream resource.
 * @param string $required_sections Is a comma separated list of sections that need to be present in file
 * to produce a result array.  If none of the requested
 * sections could be found the return value is FALSE.
 *
 *
 *
 *
 * FILE
 * FileName, FileSize, FileDateTime, SectionsFound
 *
 *
 * COMPUTED
 *
 * html, Width, Height, IsColor, and more if available.  Height and
 * Width are computed the same way getimagesize
 * does so their values must not be part of any header returned.
 * Also, html is a height/width text string to be used inside normal
 * HTML.
 *
 *
 *
 * ANY_TAG
 * Any information that has a Tag e.g. IFD0, EXIF, ...
 *
 *
 * IFD0
 *
 * All tagged data of IFD0. In normal imagefiles this contains
 * image size and so forth.
 *
 *
 *
 * THUMBNAIL
 *
 * A file is supposed to contain a thumbnail if it has a second IFD.
 * All tagged information about the embedded thumbnail is stored in
 * this section.
 *
 *
 *
 * COMMENT
 * Comment headers of JPEG images.
 *
 *
 * EXIF
 *
 * The EXIF section is a sub section of IFD0. It contains
 * more detailed information about an image. Most of these entries
 * are digital camera related.
 *
 *
 *
 *
 *
 * @param bool $as_arrays Specifies whether or not each section becomes an array. The
 * required_sections COMPUTED,
 * THUMBNAIL, and COMMENT
 * always become arrays as they may contain values whose names conflict
 * with other sections.
 * @param bool $read_thumbnail When set to TRUE the thumbnail itself is read.  Otherwise, only the
 * tagged data is read.
 * @return array It returns an associative array where the array indexes are
 * the header names and the array values are the values associated with
 * those headers. If no data can be returned,
 * exif_read_data will return FALSE.
 * @throws ExifException
 *
 */
function exif_read_data($file, string $required_sections = null, bool $as_arrays = false, bool $read_thumbnail = false): array
{
    error_clear_last();
    if ($read_thumbnail !== false) {
        $result = \exif_read_data($file, $required_sections, $as_arrays, $read_thumbnail);
    } elseif ($as_arrays !== false) {
        $result = \exif_read_data($file, $required_sections, $as_arrays);
    } elseif ($required_sections !== null) {
        $result = \exif_read_data($file, $required_sections);
    } else {
        $result = \exif_read_data($file);
    }
    if ($result === false) {
        throw ExifException::createFromPhpError();
    }
    return $result;
}


/**
 *
 *
 * @param int $index The Tag ID for which a Tag Name will be looked up.
 * @return string Returns the header name, or FALSE if index is
 * not a defined EXIF tag id.
 * @throws ExifException
 *
 */
function exif_tagname(int $index): string
{
    error_clear_last();
    $result = \exif_tagname($index);
    if ($result === false) {
        throw ExifException::createFromPhpError();
    }
    return $result;
}


/**
 * exif_thumbnail reads the embedded thumbnail of an image.
 *
 * If you want to deliver thumbnails through this function, you should send
 * the mimetype information using the header function.
 *
 * It is possible that exif_thumbnail cannot create an
 * image but can determine its size. In this case, the return value is
 * FALSE but width and height
 * are set.
 *
 * @param string $file The location of the image file. This can either be a path to the file
 * or a stream resource.
 * @param int|null $width The return width of the returned thumbnail.
 * @param int|null $height The returned height of the returned thumbnail.
 * @param int|null $image_type The returned image type of the returned thumbnail.  This is either
 * TIFF or JPEG.
 * @return string Returns the embedded thumbnail, or FALSE if the image contains no
 * thumbnail.
 * @throws ExifException
 *
 */
function exif_thumbnail(string $file, ?int &$width = null, ?int &$height = null, ?int &$image_type = null): string
{
    error_clear_last();
    $result = \exif_thumbnail($file, $width, $height, $image_type);
    if ($result === false) {
        throw ExifException::createFromPhpError();
    }
    return $result;
}
